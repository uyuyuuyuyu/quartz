# Lecture Notes: Graph Theory - Trees and Algorithms

## 1. Tree Embeddings

**Theorem 4.9**
Let $G$ be a graph and let $T$ be a tree of order $n$. If $\delta(G) \ge n-1$, then $T \subseteq G$.

### Lemma: Tree Vertex Labeling
The vertices of a nontrivial tree $T$ can be labelled $\{v_1, \dots, v_n\}$ such that each $v_i$ has precisely one neighbor in $\{v_1, \dots, v_{i-1}\}$ (the set of lower-indexed vertices).

**Proof of Lemma (Induction on $n$):**
* **Base Case ($n=1$):** $V(T) = \{v_1\}$.
* **Inductive Hypothesis (IH):** Suppose $n \ge 2$, and the desired labelling exists for trees of lower order.
* **Inductive Step:**
    * Let $v_n$ be a leaf of $T$. Then $T - v_n$ is a tree of order $n-1$.
    * Label the vertices of $T - v_n$ as $v_1, \dots, v_{n-1}$ according to the IH.
    * For $2 \le i \le n-1$, $v_i$ has exactly one neighbor of lower index. For $i=n$, $v_n$ has exactly one neighbor of lower index (since it is a leaf connected to the rest of the tree).

### Proof of Theorem 4.9
We label $V(T) = \{v_1, \dots, v_n\}$ as in the lemma. We will inductively find distinct vertices in $G$ to label $u_1, \dots, u_n$ such that edges in $T$ map to edges in $G$.

* **Base Case:** Let $u_1$ be any vertex of $G$.
* **Inductive Step:**
    * Suppose we have labelled $u_1, \dots, u_k$ in $G$ ($k < n$).
    * To embed $v_{k+1}$, note that it has exactly one neighbor in $\{v_1, \dots, v_k\}$, say $v_j$.
    * We need to find a vertex in the neighborhood $N_G(u_j)$ that hasn't been used yet (is not in $\{u_1, \dots, u_k\}$).
    * **Calculation:** Since $\delta(G) \ge n-1$, the vertex $u_j$ has at least $n-1$ neighbors in $G$. At most $k-1$ (or generally $i-1$) neighbors have been assigned labels.
    * The number of available vertices is at least:
        $$(n-1) - (i-1) \ge (n-1) - (n-2) = 1$$
    * Therefore, there is at least one available vertex to be $u_{k+1}$.

---

## 2. Minimum Spanning Trees (MST)

### Theorem 4.10 (Spanning Tree Existence)
Every connected graph $G$ has a subgraph $T$ such that $V(T) = V(G)$ and $T$ is a tree. $T$ is called a **spanning tree** of $G$.

* **Proof Idea:** Iteratively delete edges of $G$ that are not bridges until no non-bridges remain.

### Weighted Graphs
* Let $G$ be a graph with a weight function $w: E(G) \rightarrow \mathbb{R}$.
* For a subgraph $H$ of $G$, the weight of $H$ is $w(H) = \sum_{e \in E(H)} w(e)$.
* **Minimum Spanning Tree (MST):** A spanning tree of a weighted graph that has the minimum weight.

---

## 3. Kruskal's Algorithm

**Algorithm Definition (Greedy)**
Given a weighted graph $G$, set $V(T) = V(G)$ and build $E(T)$ as follows:
1.  **Step 1:** Let $e_1$ be an edge of $G$ of minimum weight.
2.  **Step 2:** Let $e_2$ be an edge of $G \setminus \{e_1\}$ of minimum weight.
3.  **Step 3:** Let $e_k$ be an edge of minimum weight in remaining edges such that adding $e_k$ creates **no cycle**.
4.  **Stop:** When the addition creates a spanning tree (no more edges can be added without cycles).

### Theorem 4.11
Kruskal's algorithm results in an MST when applied to a connected, weighted graph.

**Proof:**
Let $T$ be the result of Kruskal's algorithm.

**Part 1: $T$ is a spanning tree.**
* By design, $T$ is a spanning subgraph and is acyclic.
* We must show $T$ is connected.
* *Contradiction:* Suppose $T$ is not connected. Let $x, y$ be vertices in different components of $T$. Since $G$ is connected, there is a path $P$ in $G$ between $x$ and $y$.
* There must be an edge $ab$ on $P$ such that $a$ shares a T-component with $x$ and $b$ does not.
* Adding $ab$ to $T$ would reduce the number of components and would not create a cycle (since $a$ and $b$ were disconnected in $T$). Thus, $ab$ is a bridge in $T+ab$.
* This implies the algorithm should have considered and added $ab$ (or an equivalent edge) before finishing. Since it didn't, we have a contradiction.

**Part 2: $T$ is a Minimum Spanning Tree.**
* Suppose there is a spanning tree $H$ of $G$ such that $w(H) < w(T)$.
* Choose $H$ such that $|E(H) \cap E(T)|$ is maximum.
